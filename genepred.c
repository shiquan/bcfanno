#include "utils.h"
#include "genepred.h"
#include "htslib/kstring.h"
#include "htslib/tbx.h"

#ifndef KSTRING_INIT
#define KSTRING_INIT {0, 0, 0}
#endif

void genepred_clear(struct genepred *line)
{
    if ( line->clear == 1 )
	return;
    if (line->clear == 0) {
	free(line->chrom);
	free(line->name1);
	if ( line->name2 )
	    free(line->name2);
	free(line->exons[0]);
        free(line->exons[1]);
	free(line->dna_ref_offsets[0]);
        free(line->dna_ref_offsets[1]);
        free(line->loc[0]);
        free(line->loc[1]);
    }
    memset(line, 0, sizeof(struct genepred));
    line->clear = 1;
}

tbx_t *load_genepred_file(const char *fn)
{
    return tbx_index_load(fn);
}

// variantion descriptions
// hom-ref, ref-alt, hom-alt, multi-alt
// this tag shoule be generated by vcf2tsv
static struct genepred_format refgene_formats = {
    .chrom = 2,
    .name1 = 1,
    .name2 = 12,
    .strand = 3,
    .txstart = 4,
    .txend = 5,
    .cdsstart = 6,
    .cdsend = 7,
    .exoncount = 8,
    .exonstarts = 9,
    .exonends = 10,
};
    
static struct genepred_format genepred_formats = {    
    .name1 = 0,
    .chrom = 1,
    .strand = 2,
    .txstart = 3,
    .txend = 4,
    .cdsstart = 5,
    .cdsend = 6,
    .exoncount = 7,
    .exonstarts = 8,
    .exonends = 9,
    .name2 = 10,
};

static struct genepred_format refflat_formats = {    
    .name1 = 0,
    .name2 = 1,
    .chrom = 2,
    .strand = 3,
    .txstart = 4,
    .txend = 5,
    .cdsstart = 6,
    .cdsend = 7,
    .exoncount = 8,
    .exonstarts = 9,
    .exonends = 10,
};

static struct genepred_format *type = &genepred_formats;

void set_format_refgene()
{
    type = &refgene_formats;
}
void set_format_genepred()
{
    type = &genepred_formats;
}
void set_format_refflat()
{
    type = &refflat_formats;
}
char check_strand(char *strand)
{
    if (memcmp(strand, "+", 1) == 0 )
        return '+';
    else if (memcmp(strand, "-", 1) == 0)
        return '-';
    error("Unknow strand type, %s", strand);
}
// 0 on success, 1 on failure
static int genepred_parse_core(kstring_t *string, struct genepred *line)
{
    int nfields = 0;
    genepred_clear(line);    
    // accept any gene_pred-like format, like refGene, ensGene, gene_pred, see our manual how to get these databases
    // split the string by tab
    int *splits = ksplit(string, 0, &nfields);
#define BRANCH(l,c,f) do {\
        if (c >= nfields) {\
            l = 0;\
        } else {\
            l = f(string->s + splits[c]);\
        }\
    } while(0)
    // chromosome name
    BRANCH(line->chrom, type->chrom, strdup);
    if ( line->chrom == NULL ) 
        return 1;

    // usually gene names or ensemble gene id
    BRANCH(line->name1, type->name1, strdup);
    // strand, char '+' or '-'
    BRANCH(line->strand, type->strand, check_strand);
    // trans start
    BRANCH(line->txstart, type->txstart, atoi);
    line->txstart++;
    
    // trans end
    BRANCH(line->txend, type->txend, atoi);
    if (line->txend == 0 )
        return 1;
    // cds start, for mRNA cds start should greater than txstart, for ncRNA cdsstart should equal to txend
    BRANCH(line->cdsstart, type->cdsstart, atoi);
    line->cdsstart++;
    
    // cds end, for ncRNA cdsend == cdsstart == txend
    BRANCH(line->cdsend, type->cdsend, atoi);    
    // exon number
    BRANCH(line->exoncount, type->exoncount, atoi);
    // for some genePred file, no name2 specified.
    BRANCH(line->name2, type->name2, strdup);

#undef BRANCH
    
    // the exons region in gene_pred file is like  1,2,3,4,5. try to init the exon_pair[] 
    // and exon_offset_pair[] by exoncount
    if ( type->exonstarts >= nfields ) 
        return 1;    
    if ( type->exonends >= nfields ) 
        return 1;
    char *ss = string->s + splits[type->exonstarts];    
    char *se = string->s + splits[type->exonends];
    char *ss1, *se1;
    int i;
    for ( i = 0; i < 2; ++i ) {
        line->exons[i] = (uint32_t*)calloc(line->exoncount, sizeof(uint32_t));
        line->dna_ref_offsets[i] = (uint32_t*)calloc(line->exoncount, sizeof(uint32_t));
        line->loc[i] = (uint32_t*)calloc(line->exoncount, sizeof(uint32_t));        
    }
    free(splits);
    
    for ( i = 0; i < line->exoncount; ++i ) {
	// start
	ss1 = ss;
	while (ss1 && *ss1 != ',')
            ss1++;
	ss1[0] = '\0';
	line->exons[BLOCK_START][i] = atoi(ss) +1; // convert 0based start to 1 based
	ss = ++ss1; // skip ','
	// end
	se1 = se;
	while (se1 && *se1 != ',')
            se1++;
	se1[0] = '\0';
	line->exons[BLOCK_END][i] = atoi(se);	
	se = ++se1; // skip ','
    }
    // make sure the genepred is filled
    line->clear = 0;
    return 0;
}

void genepred_parser(kstring_t *string, struct genepred *line)
{    
    // parse string into genepred line struct
    if ( genepred_parse_core(string, line) == 1)
        error("Format error. Failed to parse line, %s.", string->s);
    
    // calculate the length of function regions, for plus strand, forward length is the length of UTR5, and
    // backward length is the length of UTR3, for minus strand 

    int read_len = 0;
    int fwd_len = 0;
    int bkw_len = 0;
    int is_coding = line->cdsstart == line->cdsend ? 0 : 1;
    int i;
    int loc = 0;
    int exon_start, exon_end, exon_len;
    int is_strand = line->strand == '+';
    // The purpose of this loop is calculating the forward length and backward length. For plus strand,
    // forward is UTR5 as well as backward is UTR3. and vice versa.
    // Meanwhile, the related location of the transcripts block edges also will be calculated and locs
    // will be remembered in genpred::loc[][].
    for ( i = 0; i < line->exoncount; ++i ) {
        
        exon_start = line->exons[BLOCK_START][i];
        exon_end = line->exons[BLOCK_END][i];
        // for genepred format, start is 0 based, end is 1 based
        exon_len = exon_end - exon_start + 1;

        // Set related location of the transcript block edges. assume all the transcript is plus strand
        // here. for minus strand the locations will be reversed.
        line->loc[BLOCK_START][i] = ++loc;
        loc = loc + exon_len - 1;
        line->loc[BLOCK_END][i] = loc; 

	// Add exon length to dna reference length, the reference length should be equal to the length of
        // transcript, including UTRs for coding transcript.
	line->reference_length += exon_len;
        
	// only mRNA has UTRs
	if (is_coding == 0)
            continue;

        // count forward length
	if (line->exons[BLOCK_END][i] <= line->cdsstart) {
	    fwd_len += exon_len;
	    continue;
	}
        
	// first cds 
	if (line->cdsstart > line->exons[BLOCK_START][i]) {
	    fwd_len += line->cdsstart - line->exons[BLOCK_START][i];
            // if only one exon with one cds included
            if ( line->cdsend < line->exons[BLOCK_END][i]) {
                bkw_len = line->exons[BLOCK_END][i] - line->cdsend;
            }
	    continue;
	} 
	// come to end regions, count backward length
	if (line->cdsend <= line->exons[BLOCK_START][i]) {
	    bkw_len += exon_len;
	    continue;
	}
	// last cds
	if (line->cdsend < line->exons[BLOCK_END][i]) {
	    bkw_len += line->exons[BLOCK_END][i] - line->cdsend;
	}		   
    }
    
    // read_len is the coding reference length for coding transcript or length of noncoding transcript 
    read_len = line->reference_length - fwd_len - bkw_len;
    // init forward and backward length
    if ( is_strand ) {
        line->forward_length = fwd_len;
        line->backward_length = bkw_len;
    } else {
        line->forward_length = bkw_len;
        line->backward_length = fwd_len;
    }
    

    // for minus strand, reverse the transcript locations of genepred::loc[][], becase minus transcript
    // encode from backward
    if ( line->strand == '-') {
        for (i = 0; i < line->exoncount; ++i ) {
            line->loc[BLOCK_START][i] = line->reference_length - line->loc[BLOCK_START][i] + 1;
            line->loc[BLOCK_END][i] = line->reference_length - line->loc[BLOCK_END][i] + 1;
        }        
    }


    // calculate the genepred::dna_ref_offsets[][]
    
    // Coding DNA reference:
    //                   -3                                            *3
    //                    -2                                          *2
    // -93   -45 -44       -1 1                187 188           351 *1   *96 *97    *223
    // |_______|____________|====================|=================|________|_______|
    //        / \            ATG                / \             TGA        / \
    //       /   \                             /   \                      /   \
    //      /gtga,,,g                         /gta,,,act                 /gtag,,,cc
    //  -45+1        -44-1                187+1        188-1         *96+1        *97-1
    //   -45+2      -44-2                  187+2      188-2           *96+2      *97-2
    //    -45+3    -44-3                    187+3    188-3             *96+3    *97-3
    // 
    // 
    // Noncoding DNA reference:
    // 
    // 1        49 50             280 281                 540 541             667
    // |__________|__________________|_______________________|_________________|
    //     
    int l1 = 0, l2 = line->exoncount - 1;
    // count forward
    int forward_offset = 0;
    int backward_offset = 0;
    
    // count utr blocks leftside   
    for ( ; l1 < line->exoncount && fwd_len; ++l1 ) {
        exon_len = line->exons[BLOCK_END][l1] - line->exons[BLOCK_START][l1]+1;

	line->dna_ref_offsets[BLOCK_START][l1] = compact_loc(fwd_len, is_strand ? REG_UTR5 : REG_UTR3);
        
	if ( fwd_len > exon_len ) {
	    fwd_len -= exon_len;
 	    line->dna_ref_offsets[BLOCK_END][l1] = compact_loc(fwd_len+1, is_strand? REG_UTR5 : REG_UTR3);
	    continue;
	}

        if ( is_strand ) {
            forward_offset = exon_len - fwd_len;
            if ( forward_offset > read_len ) { // one exon within cds included
                line->dna_ref_offsets[BLOCK_END][l1] = compact_loc(forward_offset - read_len, REG_UTR3);
            } else {
                line->dna_ref_offsets[BLOCK_END][l1] = compact_loc(forward_offset, REG_CODING);
            }
        } else {
            // for minus strand count from backward
            forward_offset =  read_len + fwd_len - exon_len +1;
            if ( forward_offset < 0 ) {
                forward_offset += bkw_len + 1;
                line->dna_ref_offsets[BLOCK_END][l1] = compact_loc(forward_offset, REG_UTR5);
            } else {
                line->dna_ref_offsets[BLOCK_END][l1] = compact_loc(forward_offset, REG_CODING);
            }
        }
	fwd_len = 0;
	++l1;
	break;
    }

    // count utr blocks rightside
    for ( ; l2 > 0 && l2 > l1 && bkw_len; --l2 ) {
        exon_len = line->exons[BLOCK_END][l2] - line->exons[BLOCK_START][l2] + 1;

	line->dna_ref_offsets[BLOCK_END][l2] = compact_loc(bkw_len, is_strand ? REG_UTR3 : REG_UTR5);

	if (bkw_len > exon_len) {
	    bkw_len -= exon_len;
	    line->dna_ref_offsets[BLOCK_START][l2] = compact_loc(bkw_len+1, is_strand ? REG_UTR3 : REG_UTR5);
	    continue;
	}
        if ( is_strand ) {
            backward_offset = read_len + bkw_len - exon_len;
            if ( backward_offset < 0 ) {
                backward_offset = -backward_offset;                
                line->dna_ref_offsets[BLOCK_START][l2] = compact_loc(-backward_offset, REG_UTR5); 
            } else {
                line->dna_ref_offsets[BLOCK_START][l2] = compact_loc(backward_offset+1, REG_CODING);                
            }
        } else {
            backward_offset = exon_len - bkw_len;
            if ( backward_offset > read_len ) {
                backward_offset -= read_len;
                line->dna_ref_offsets[BLOCK_START][l2] = compact_loc(backward_offset, REG_UTR5);                
            } else {
                line->dna_ref_offsets[BLOCK_START][l2] = compact_loc(backward_offset, REG_CODING);                
            }
        }
	bkw_len = 0;
	--l2;
	break;
    }
    if ( l1 >= l2 )
        return;
    // count inter regions
    if ( is_strand ) {
	if (is_coding && backward_offset)
	    read_len = backward_offset;       
	int l;
	for ( l = l2; l >= l1;  l-- ) {
            exon_len = line->exons[BLOCK_END][l] - line->exons[BLOCK_START][l] + 1;
	    line->dna_ref_offsets[BLOCK_END][l] = compact_loc(read_len, is_coding ? REG_CODING : REG_NONCODING);
	    read_len -= exon_len;
	    line->dna_ref_offsets[BLOCK_START][l] = compact_loc(read_len+1,is_coding ? REG_CODING : REG_NONCODING);
	}
    } else {
	if (is_coding && forward_offset) 
	    read_len = forward_offset;
	
	int l;
	for ( l = l1; l <= l2; l++ ) {
            exon_len = line->exons[BLOCK_END][l] - line->exons[BLOCK_START][l] +1 ;
	    line->dna_ref_offsets[BLOCK_START][l] = compact_loc(read_len,is_coding ? REG_CODING : REG_NONCODING);
	    read_len -= exon_len;
	    line->dna_ref_offsets[BLOCK_END][l] = compact_loc(read_len+1,is_coding ? REG_CODING : REG_NONCODING);
        }
    }
}

void generate_dbref_database(struct genepred *line)
{
    if (line->clear == 1)
        return;
    int i;
    kstring_t temp[2] = { KSTRING_INIT, KSTRING_INIT };
    int types[2];
    for ( i = 0; i < line->exoncount; ++i ) {
        temp[0].l = temp[1].l = 0;
    	types[0] = line->dna_ref_offsets[BLOCK_START][i] & REG_MASK;
    	types[1] = line->dna_ref_offsets[BLOCK_END][i] & REG_MASK;
    	int j;
	// [start, end] 
    	for ( j = 0; j < 2; ++j ) {
    	    kstring_t *temp1 = &temp[j];
    	    int t = types[j];
    	    switch ( t ) {
    		case REG_UTR5:
    		    kputc('-', temp1);
    		    break;
    		case REG_UTR3:
    		    kputc('*', temp1);
    		    break;
    		case REG_CODING:
    		    kputs("c.", temp1);
    		    break;
    		case REG_NONCODING:
    		    kputs("n.", temp1);
    		    break;
    		default:
    		    error("Unknown type : %d", t);
    	    }
    	}
    	kputw((line->dna_ref_offsets[BLOCK_START][i]>>TYPEBITS), &temp[0]);
    	kputw((line->dna_ref_offsets[BLOCK_END][i]>>TYPEBITS), &temp[1]);
        int exon_id = line->strand == '+' ? i + 1 : line->exoncount -i;
	// format: CHROM,START,END,STRAND, GENE, TRANSCRIPT, EXON, START_LOC, END_LOC
        fprintf(stdout, "%s\t%d\t%d\t%c\t%s\t%s\tEX%d\t%d\t%d\t%s\t%s\n",
                line->chrom,  // chromosome
                read_start(line->exons, i)-1, // start, 0 based
                read_end(line->exons,i),
                line->strand,
                line->name2,
                line->name1,
                exon_id,
                read_start(line->loc, i),
                read_end(line->loc, i),
                temp[0].s,
                temp[1].s);
        temp[0].l = temp[1].l = 0;
    }
    free(temp[0].s);
    free(temp[1].s);
}

char *gp_describe(struct genepred *line)
{
    kstring_t string = KSTRING_INIT;
    kputs(line->chrom, &string);
    kputc(',', &string);
    kputw(line->txstart, &string);
    kputc(',', &string);
    kputw(line->txend, &string);
    return string.s;
}

// memory pool 
void gp_push_mempool(struct gp_mempool *pool, kstring_t *str)
{
    if (pool->m == pool->l) {
	pool->m = pool->m == 0 ? 2 : pool->m << 1;
	pool->a = (struct genepred *)realloc(pool->a, sizeof(struct genepred)*pool->m);
    }
    // i should always greater than l. if i == l increase i to init a new line for future use. go abort if i < l
    if (pool->i == pool->l) {
      memset(&pool->a[pool->i], 0, sizeof(struct genepred));
      pool->a[pool->i++].clear = 1;
    }
    // the parse func must return a point or go abort
    genepred_parser(str, &pool->a[pool->l]);
    pool->l++;
}
void gp_update_mempool(struct gp_mempool *pool)
{    
    if (pool->l == 0)
	return;
    // try to loop this pool and find the edges
    pool->start = pool->a[0].txstart;
    pool->end = pool->a[0].txend;
    int i;    
    for ( i = 1; i < pool->l; ++i ) {
	if ( pool->a[i].txstart < pool->start )
	    pool->start = pool->a[i].txstart;
	if ( pool->a[i].txend > pool->end )
	    pool->end = pool->a[i].txend;
    }
}
void gp_clear_mempool(struct gp_mempool *pool)
{
    int i;
    for ( i = 0; i < pool->i; ++i)
	genepred_clear(&pool->a[i]);
    
    pool->l = 0;
    // i and m should be kept for future use
    pool->start = 0;
    pool->end = 0;
    pool->rid = -1;
}
